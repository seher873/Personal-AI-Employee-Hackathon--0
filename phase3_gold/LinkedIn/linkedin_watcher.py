#!/usr/bin/env python3
"""
LinkedIn Watcher for new messages and notifications.
Implements Watcher Skill from SKILL.md
Monitors LinkedIn for new messages and notifications, saves them to vault.
"""

import os
import sys
import time
import random
import logging
from datetime import datetime
from pathlib import Path
from dotenv import load_dotenv
from playwright.sync_api import sync_playwright

# Load environment variables
load_dotenv()

# Check Python version
if sys.version_info < (3, 13):
    print(f"Error: Python 3.13 or higher is required. Current version: {sys.version}")
    sys.exit(1)

# Configure logging
log_file = Path("Logs/linkedin_watcher.log")
log_file.parent.mkdir(parents=True, exist_ok=True)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)

# Configuration
LINKEDIN_EMAIL = os.getenv("LINKEDIN_EMAIL", "sehrkhan873@gmail.com")
LINKEDIN_PASSWORD = os.getenv("LINKEDIN_PASSWORD", "")
USER_DATA_DIR = "./linkedin_session"
VAULT_PATH = "./Inbox"
ERROR_SCREENSHOT = "linkedin_error.png"
POLL_INTERVAL = 90  # seconds (increased for slow connections)
MAX_RETRIES = 3
HEADLESS = True  # WSL2 doesn't support visible browser, use headless mode
BROWSER_TIMEOUT = 90000  # 90 seconds for page loads
ELEMENT_TIMEOUT = 10000  # 10 seconds for element interactions

# Ensure vault directory exists
Path(VAULT_PATH).mkdir(parents=True, exist_ok=True)
Path(USER_DATA_DIR).mkdir(parents=True, exist_ok=True)


def human_like_delay(min_ms=50, max_ms=200):
    """Add human-like delay"""
    time.sleep(random.randint(min_ms, max_ms) / 1000)


def random_mouse_move(page):
    """Perform random mouse movements"""
    try:
        x = random.randint(100, 1200)
        y = random.randint(100, 800)
        page.mouse.move(x, y)
        human_like_delay(100, 300)
    except Exception:
        pass


def save_to_vault(data, message_type="message"):
    """Save LinkedIn data to vault"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    filename = f"{VAULT_PATH}/new_linkedin_{message_type}_{timestamp}.md"

    content = f"""# New LinkedIn {message_type.title()}

**From:** {data.get('sender', 'Unknown')}
**Time:** {data.get('time', 'Unknown')}
**Content:** {data.get('text', 'No content')}

---
*Generated by LinkedIn Watcher at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*
"""

    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content.strip())

    logging.info(f"Saved to vault: {filename}")
    return filename


def check_new_messages(page):
    """Check for new LinkedIn messages"""
    try:
        # Navigate to messaging page
        page.goto("https://www.linkedin.com/messaging/", wait_until="domcontentloaded", timeout=BROWSER_TIMEOUT)
        human_like_delay(500, 1000)

        # Look for unread indicators
        unread_selectors = [
            'li.msg-conversation-listitem--unread',
            '.msg-conversation-card__unread-count',
            '[data-test-unread-count]',
            '.msg-conversation-card__unread-dot'
        ]

        for selector in unread_selectors:
            try:
                unread_elements = page.locator(selector).all()
                if unread_elements:
                    logging.info(f"Found {len(unread_elements)} unread messages")

                    for element in unread_elements[:3]:  # Process first 3 unread messages
                        try:
                            # Extract sender name
                            sender_selectors = [
                                '.msg-conversation-card__participant-names',
                                '.msg-conversation-card__title',
                                '[data-test-conversation-participant-names]'
                            ]

                            sender = "Unknown"
                            for sender_selector in sender_selectors:
                                try:
                                    sender_elem = element.locator(sender_selector).first
                                    if sender_elem.count() > 0:
                                        sender = sender_elem.inner_text(timeout=ELEMENT_TIMEOUT)
                                        break
                                except Exception:
                                    continue

                            # Get preview text
                            preview_selectors = [
                                '.msg-conversation-card__message-snippet',
                                '.msg-conversation-card__snippet',
                                '[data-test-conversation-snippet]'
                            ]

                            text = "No preview available"
                            for preview_selector in preview_selectors:
                                try:
                                    preview_elem = element.locator(preview_selector).first
                                    if preview_elem.count() > 0:
                                        text = preview_elem.inner_text(timeout=ELEMENT_TIMEOUT)
                                        break
                                except Exception:
                                    continue

                            # Get time
                            time_selectors = [
                                '.msg-conversation-card__time-stamp',
                                '[data-test-timestamp]'
                            ]

                            message_time = "Unknown"
                            for time_selector in time_selectors:
                                try:
                                    time_elem = element.locator(time_selector).first
                                    if time_elem.count() > 0:
                                        message_time = time_elem.inner_text(timeout=ELEMENT_TIMEOUT)
                                        break
                                except Exception:
                                    continue

                            # Save to vault
                            message_data = {
                                'sender': sender.strip(),
                                'text': text.strip(),
                                'time': message_time.strip()
                            }
                            save_to_vault(message_data, "message")

                        except Exception as e:
                            logging.error(f"Error processing message: {e}")
                            continue

                    break

            except Exception:
                continue

    except Exception as e:
        logging.error(f"Error checking messages: {e}")
        try:
            page.screenshot(path=ERROR_SCREENSHOT)
        except Exception:
            pass
        raise


def check_new_notifications(page):
    """Check for new LinkedIn notifications"""
    try:
        # Navigate to notifications page
        page.goto("https://www.linkedin.com/notifications/", wait_until="domcontentloaded", timeout=BROWSER_TIMEOUT)
        human_like_delay(500, 1000)

        # Look for unread notifications
        unread_selectors = [
            '.nt-segment--unread',
            '[data-test-notification-item].nt-segment--unread',
            '.notification-badge--show'
        ]

        for selector in unread_selectors:
            try:
                unread_elements = page.locator(selector).all()
                if unread_elements:
                    logging.info(f"Found {len(unread_elements)} unread notifications")

                    for element in unread_elements[:3]:  # Process first 3
                        try:
                            # Extract notification text
                            text_selectors = [
                                '.nt-card__text',
                                '.nt-card__headline',
                                '[data-test-notification-headline]'
                            ]

                            text = "No notification text"
                            for text_selector in text_selectors:
                                try:
                                    text_elem = element.locator(text_selector).first
                                    if text_elem.count() > 0:
                                        text = text_elem.inner_text(timeout=ELEMENT_TIMEOUT)
                                        break
                                except Exception:
                                    continue

                            # Get time
                            time_selectors = [
                                '.nt-card__time-ago',
                                '[data-test-notification-time-ago]'
                            ]

                            notification_time = "Unknown"
                            for time_selector in time_selectors:
                                try:
                                    time_elem = element.locator(time_selector).first
                                    if time_elem.count() > 0:
                                        notification_time = time_elem.inner_text(timeout=ELEMENT_TIMEOUT)
                                        break
                                except Exception:
                                    continue

                            # Save to vault
                            notification_data = {
                                'sender': 'LinkedIn Notification',
                                'text': text.strip(),
                                'time': notification_time.strip()
                            }
                            save_to_vault(notification_data, "notification")

                        except Exception as e:
                            logging.error(f"Error processing notification: {e}")
                            continue

                    break

            except Exception:
                continue

    except Exception as e:
        logging.error(f"Error checking notifications: {e}")
        try:
            page.screenshot(path=ERROR_SCREENSHOT)
        except Exception:
            pass
        raise


def linkedin_watcher():
    """Main LinkedIn watcher function"""
    logging.info("Starting LinkedIn Watcher...")
    logging.info(f"Email: {LINKEDIN_EMAIL}")
    logging.info(f"Headless: {HEADLESS}")
    logging.info(f"Poll Interval: {POLL_INTERVAL} seconds")

    retries = 0

    while retries < MAX_RETRIES:
        try:
            logging.info(f"Attempt {retries + 1}/{MAX_RETRIES}")

            with sync_playwright() as p:
                # Launch browser
                browser = p.chromium.launch(
                    headless=HEADLESS,
                    args=[
                        '--disable-blink-features=AutomationControlled',
                        '--disable-dev-shm-usage',
                        '--no-sandbox',
                        '--disable-setuid-sandbox'
                    ]
                )

                context = browser.new_context(
                    storage_state=USER_DATA_DIR + "/storage_state.json" if os.path.exists(USER_DATA_DIR + "/storage_state.json") else None
                )
                page = context.new_page()
                page.set_default_timeout(ELEMENT_TIMEOUT)
                page.set_default_navigation_timeout(BROWSER_TIMEOUT)

                # Navigate to LinkedIn
                page.goto("https://www.linkedin.com/login", wait_until="domcontentloaded", timeout=BROWSER_TIMEOUT)
                human_like_delay(500, 1000)

                # Check if already logged in
                if "feed" in page.url or "mynetwork" in page.url:
                    logging.info("Already logged in")
                else:
                    if not LINKEDIN_PASSWORD:
                        logging.error("No password provided. Please set LINKEDIN_PASSWORD in .env file")
                        browser.close()
                        return

                    logging.info("Logging in...")

                    # Fill login form
                    try:
                        page.fill('input[name="session_key"]', LINKEDIN_EMAIL)
                        human_like_delay(500, 1000)
                        page.fill('input[name="session_password"]', LINKEDIN_PASSWORD)
                        human_like_delay(500, 1000)

                        # Click login button
                        page.click('button[type="submit"]')
                        human_like_delay(1000, 2000)

                        # Wait for navigation
                        page.wait_for_url("https://www.linkedin.com/feed/*", timeout=BROWSER_TIMEOUT)

                    except Exception as login_error:
                        logging.error(f"Login error: {login_error}")
                        browser.close()
                        raise Exception("Login failed")

                logging.info("Successfully logged in to LinkedIn")

                # Main polling loop
                while True:
                    try:
                        logging.info(f"\n[{datetime.now()}] Checking for new LinkedIn activity...")

                        # Random mouse movement
                        random_mouse_move(page)

                        # Check messages
                        check_new_messages(page)
                        human_like_delay(500, 1000)

                        # Check notifications
                        check_new_notifications(page)
                        human_like_delay(500, 1000)

                        logging.info(f"Sleeping for {POLL_INTERVAL} seconds...")
                        time.sleep(POLL_INTERVAL)

                    except KeyboardInterrupt:
                        logging.info("Watcher stopped by user")
                        break
                    except Exception as e:
                        logging.error(f"Error in polling loop: {e}")
                        try:
                            page.screenshot(path=ERROR_SCREENSHOT)
                        except Exception:
                            pass
                        time.sleep(POLL_INTERVAL)
                        continue

                browser.close()
                break

        except Exception as e:
            logging.error(f"Attempt {retries + 1} failed: {e}")
            retries += 1
            if retries < MAX_RETRIES:
                logging.info("Retrying in 10 seconds...")
                time.sleep(10)
            else:
                logging.error("Max retries reached. Exiting.")
                raise


def main():
    """Main entry point for LinkedIn watcher."""
    print("Starting LinkedIn Watcher...")
    print("This implements Watcher Skill from SKILL.md")
    print(f"Email: {LINKEDIN_EMAIL}")
    print(f"Headless: {HEADLESS}")
    print("Press Ctrl+C to stop\n")

    try:
        linkedin_watcher()
    except KeyboardInterrupt:
        print("\nWatcher stopped by user")
    except Exception as e:
        print(f"Fatal error: {e}")
        logging.error(f"Fatal error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
